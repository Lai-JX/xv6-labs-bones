1. 由 li a2,13 和 li a1,12可知，a1和a2寄存器包含了传递给函数的参数，其中a2寄存器含有main函数传递给printf函数的参数13

2. 汇编程序中没有直接调用函数f的代码，由li a1,12可知f(8)+1的结果直接被计算出来了，说明编译器进行了内联；同时函数g的代码和f一样，说明也进行了内联

3. 由指令jalr 1528(ra) # 628 <printf>可知，函数printf的地址为`0x628`  (和之前不太一样？之前是630)

4. 指令jalr 会将 pc+4 存储给指定的寄存器 ra，所以 ra=0x38

5. 输出为He110 World，%x表示以十六进制进行输出，57616对应的16进制为e110，结合前面的H便形成He110；
   在ASCALL码中0x64对应d，0x6d对应l，0x72对应r，由于RIAC-V采用的是小端对齐，所以会依次读出0x72(r)、0x6d(l)、0x64(d)，结合前面的Wo形成World
   如果采用大端对齐，57616不用改变，0x00646c72需改为0x726c6400
6. y对应的是寄存器a2的值，由于没有提前给a2赋值，所以这个值是不确定的